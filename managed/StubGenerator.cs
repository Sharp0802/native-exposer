using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace NativeExposer;

[Generator(LanguageNames.CSharp)]
public class StubGenerator : IIncrementalGenerator
{
    private const string Namespace     = "NativeExposer";
    private const string AttributeName = "ExportAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("ExportAttribute.cs",
                $$"""
                  // <auto-generated />

                  using System;

                  namespace {{Namespace}} {
                      [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
                      internal sealed class {{AttributeName}} : Attribute {}
                      
                      public static class Internal {
                          public delegate void FreeDelegate(IntPtr ptr);
                          
                          public static void Free(IntPtr ptr) {
                              System.Runtime.InteropServices.GCHandle.FromIntPtr(ptr).Free();
                          }
                      }
                  }
                  """);
        });

        var sources = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{Namespace}.{AttributeName}",
            static (_, _) => true,
            static (c, _) => c);

        context.RegisterSourceOutput(sources, Emit);
    }

    private static void WriteParameters(IMethodSymbol symbol, StringBuilder builder)
    {
        if (!symbol.IsStatic && !symbol.IsCtor())
        {
            builder.Append("global::System.IntPtr __pThis");
            if (symbol.Parameters.Length > 0)
                builder.Append(", ");
        }

        for (var i = 0; i < symbol.Parameters.Length; i++)
        {
            if (i > 0)
                builder.Append(", ");

            var param = symbol.Parameters[i];
            builder.Append(param.Type.ToBridgeType()).Append(' ').Append(param.Name);
        }
    }

    private static void WriteArguments(IMethodSymbol symbol, StringBuilder builder)
    {
        for (var i = 0; i < symbol.Parameters.Length; i++)
        {
            if (i > 0)
                builder.Append(", ");

            var param = symbol.Parameters[i];
            if (param.Type.IsReferenceType)
                builder.Append("global::System.Runtime.InteropServices.GCHandle.FromIntPtr(");

            builder.Append(param.Name);

            if (param.Type.IsReferenceType)
                builder.Append(").Target as global::").Append(param.Type.GetFullName("."));
        }
    }

    private static void Emit(SourceProductionContext spc, GeneratorAttributeSyntaxContext gasc)
    {
        var symbol = (IMethodSymbol)gasc.TargetSymbol;
        var mangle = symbol.Mangle();

        // opening

        var builder = new StringBuilder();

        builder
            .Append("namespace ").Append(symbol.ContainingType.ContainingNamespace.GetFullName(".")).Append(";\n")
            .Append('\n')
            .Append("public partial class ").Append(symbol.ContainingType.Name).Append(" {\n");

        // stub delegate

        builder
            .Append("\tpublic delegate ").Append(symbol.ReturnType.ToBridgeType())
            .Append(" __delegate").Append(mangle)
            .Append('(');

        WriteParameters(symbol, builder);

        builder.Append(");\n\n");

        // stub interface

        builder.Append(
            "\t[global::System.Runtime.InteropServices.UnmanagedCallersOnly(CallConvs = new[] { typeof(global::System.Runtime.CompilerServices.CallConvCdecl) })]\n");

        var ret = (symbol.IsCtor() ? symbol.ContainingType : symbol.ReturnType).ToBridgeType();
        builder
            .Append("\tpublic static ").Append(ret)
            .Append(' ').Append(mangle)
            .Append('(');

        WriteParameters(symbol, builder);

        builder.Append(") {\n");

        // stub body

        if (!symbol.IsStatic && !symbol.IsCtor())
        {
            builder.Append("\t\tvar __this = global::System.Runtime.InteropServices.GCHandle.FromIntPtr(__pThis);\n");
        }

        builder.Append("\t\t");
        if (!symbol.ReturnsVoid || symbol.IsCtor())
            builder.Append("return ");

        if (symbol.ReturnType.IsReferenceType || symbol.IsCtor())
        {
            builder.Append("global::System.Runtime.InteropServices.GCHandle.ToIntPtr(");
            builder.Append("global::System.Runtime.InteropServices.GCHandle.Alloc(");
        }

        if (!symbol.IsStatic && !symbol.IsCtor())
        {
            builder
                .Append("(__this.Target as global::")
                .Append(symbol.ContainingType.GetFullName("."))
                .Append(").");
        }

        if (symbol.IsCtor())
            builder.Append("new ").Append(symbol.ContainingType.Name);
        else
            builder.Append(symbol.Name);

        builder.Append('(');

        WriteArguments(symbol, builder);

        if (symbol.ReturnType.IsReferenceType || symbol.IsCtor())
            builder.Append("))");

        builder
            .Append(");\n")
            .Append("\t}\n");

        // closing

        builder.Append("}\n");

        var src = SourceText.From(builder.ToString(), Encoding.UTF8);
        spc.AddSource($"{symbol.ContainingType.Name}.{mangle}.g.cs", src);
    }
}